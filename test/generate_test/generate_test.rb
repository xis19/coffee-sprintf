#! /usr/bin/ruby
# encoding: UTF-8

=begin
  Generate sprintf test script

  This script generates CoffeeScript for sprintf test. Mainly it compares the CoffeeScript sprintf output with C printf
  output. Some non-C99 compatible conversion_specifier have referred Ruby sprintf implementation/test.

  Copyright (c) 2015, Xiaoge Su
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  * Neither the name of coffee-sprintf nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
=end

# Flags for gcc
# C_COMPILER = 'gcc'
# C_OUTPUT_FILE = '/tmp/sprintf_test'
# C_COMPILER_FLAGS = %W{-O0 -std=c99 -o#{C_OUTPUT_FILE} -x c -}

# Flags for tcc, tcc compiles much faster than gcc
C_COMPILER = 'tcc'
C_OUTPUT_FILE = '/tmp/sprintf_test'
C_COMPILER_FLAGS = %W{-o#{C_OUTPUT_FILE} -}


C_FILE_TEMPLATE = <<EOF
#include <stdio.h>

int main(void) {
    printf(%{sprintf_args});

    return 0;
}
EOF

OUTPUT_COFFEE_SCRIPT_FILE = '../sprintf.coffee'
COFFEESCRIPT_BANNER = <<EOF
###
  sprintf test

  Generated by generate_sprintf_test.rb
###
EOF
TEST_FUNCTION_FORMAT = 'test "sprintf conversion specifier %{conversion_specifier}", ->'
TEST_EQUAL_FORMAT = '  strictEqual(sprintf(%{sprintf_args}), %{expected}, %{description})'
TEST_EXCEPTION_FORMAT = '  throws((-> sprintf(%{sprintf_args})), Error, %{description})'

class Char
  attr_reader :char

  def initialize(char)
    raise TypeError.new("Expecting String, got #{char.class}") unless char.is_a?(String)
    raise ArgumentError.new("Expecting one character, got #{char.length}") unless char.length == 1
    @char = char
  end

  def to_s
    @char
  end

  def length
    1
  end
end

# @param [Array] flags
# @param [Array] widths
# @param [Array] precisions
# @param [String] specifier
# @param [Array] values
# @return [Array]
def generate_compatible_test_args(flags, widths, precisions, specifier, values)
  values.flat_map do |value|
    precisions.flat_map do |precision|
      widths.flat_map do |width|
        (0..flags.length).flat_map { |l| flags.combination(l).flat_map { |a| a.join('') } }.map do |flag|
          ["%#{flag}#{width}#{precision}#{specifier}", value]
        end
      end
    end
  end
end

# :compatible Compatible with C99
# :incompatible Incompatible with C99
TEST_SPRINTF_SETS = {
    invalid: {
        incompatible: {
            ['%.**d', 10] => :sprintfException,
            ['%.5+05d', 10] => :sprintfException,
        }
    },
    percentage: {
        compatible: [
            ['%%'],
            ['%%%%']
        ]
    },
    unsupported: {
        incompatible: {
            # q is not a valid conversion specifier
            ['%q'] => :sprintfException
        }
    },
    c: {
        incompatible: {
            # Accept single UTF-8 character, it should have length 1
            ['%c', Char.new('萌')] => '萌',
            # Accept an integer larger than 255, get the corresponding charCodeAt value
            ['%c', 94043] => '潛',
            # Do not accept floats
            ['%c', 94043.34049] => :sprintfException,
            # Throw exception when received a string with length other than 1
            ['%c', ''] => :sprintfException,
            ['%c', 'abcd'] => :sprintfException,
            # Do not accept other type of objects
            ['%c', :'[1, 2, 3]'] => :sprintfException,
            ['%c', :null] => :sprintfException,
            ['%c', :undefined] => :sprintfException,
        },
        compatible: generate_compatible_test_args(['-'], [5, ''], [''], 'c', [Char.new('x')])
    },
    # 'i' specifier is the same to 'd'
    d: {
        incompatible: {
            # NaN
            ['%d', :NaN] => 'NaN',
            # NaN with flag
            ['%+d', :NaN] => 'NaN',
            # NaN with width,
            ['%10d', :NaN] => '       NaN',
            ['%-10d', :NaN] => 'NaN       ',
            ['%08d', :NaN] => '     NaN',
            # NaN with width/precision
            ['%.5d', :NaN] => 'NaN',
            ['%10.5d', :NaN] => '       NaN',
            # Infinity
            ['%d', :Infinity] => 'Infinity',
            ['%d', :'-Infinity'] => '-Infinity',
            # Infinity with width
            ['%10d', :Infinity] => '  Infinity',
            ['%10d', :'-Infinity'] => ' -Infinity',
            ['%-10d', :Infinity] => 'Infinity  ',
            ['%-10d', :'-Infinity'] => '-Infinity ',
            # Infinity with flags
            ['%+10d', :Infinity] => ' +Infinity',
            ['%+10d', :'-Infinity'] => ' -Infinity',
            ['%-+10d', :Infinity] => '+Infinity ',
            ['%-+10d', :'-Infinity'] => '-Infinity ',
            ['%.10d', :Infinity] => 'Infinity',
            ['%010d', :Infinity] => '  Infinity',
        },
        compatible: generate_compatible_test_args(
            ['+', '-', '0', ' '], [10, 2, ''], ['.5', '.1', '.0', '.', ''], 'd', [0, 128, -128])
    },
    x: {
        incompatible: {
            # NaN
            ['%d', :NaN] => 'NaN',
            # NaN with flag
            ['%+d', :NaN] => 'NaN',
            # NaN with width,
            ['%10d', :NaN] => '       NaN',
            ['%-10d', :NaN] => 'NaN       ',
            ['%08d', :NaN] => '     NaN',
            # NaN with width/precision
            ['%.5d', :NaN] => 'NaN',
            ['%10.5d', :NaN] => '       NaN',
            # Infinity
            ['%d', :Infinity] => 'Infinity',
            ['%d', :'-Infinity'] => '-Infinity',
            # Infinity with width
            ['%10d', :Infinity] => '  Infinity',
            ['%10d', :'-Infinity'] => ' -Infinity',
            ['%-10d', :Infinity] => 'Infinity  ',
            ['%-10d', :'-Infinity'] => '-Infinity ',
            # Infinity with flags
            ['%+10d', :Infinity] => ' +Infinity',
            ['%+10d', :'-Infinity'] => ' -Infinity',
            ['%-+10d', :Infinity] => '+Infinity ',
            ['%-+10d', :'-Infinity'] => '-Infinity ',
            ['%.10d', :Infinity] => 'Infinity',
            ['%010d', :Infinity] => '  Infinity',
            # Negative number
            ['%x', -127] => :sprintfException
        },
        compatible: generate_compatible_test_args(
            ['+', '-', '0', ' ', '#'], [10, 1, ''], ['.5', '.1', '.0', '.', ''], 'x', [0, 127])
    },
    X: {
        compatible: generate_compatible_test_args([], [''], [''], 'X', [127, 60000])
    },
    o: {
        compatible: generate_compatible_test_args(
            ['+', '-', '0', ' ', '#'], [10, 1, ''], ['.5', '.1', '.0', '.', ''], 'x', [0, 8, 127])
    },
    # 'F' specifier is the same to 'f' specifier
    # NOTE: When using 5.0625 the rounding results between C and JavaScript were different. Hence used 5.0626 for test.
    f: {
        compatible: generate_compatible_test_args(
            ['0', '-', '+', ' ', '#'], [10, 3, ''], ['.8', '.3', '.2', '.0', '.', ''], 'f',
            [0.0, 0.6376, -0.6376, 5.0, -5.0, 625.0626, -625.0626, 65535.9999847412109375, -65535.9999847412109375])
    },
    e: {
        compatible: generate_compatible_test_args(
            ['0', '-', '+', ' ', '#'], [10, 3, ''], ['.8', '.3', '.2', '.0', '.', ''], 'e',
            [0.0, 0.6376, -0.6376, 5.0, -5.0, 625.0626, -625.0626, 65535.9999847412109375, -65535.9999847412109375])
    },
    s: {
        incompatible: {
            # Accept implicit conversions from JavaScript
            ['%s', :null] => 'null',
            ['%s', :undefined] => 'undefined',
            ['%s', :NaN] => 'NaN',
            ['%s', 3] => '3',
            ['%s', 3.14] => '3.14',
            ['%s', :'[1, 2, 3]'] => '1,2,3'
        },
        compatible: generate_compatible_test_args(['-'], [256, 16, ''], ['.5', ''], 's', ['el cazador de la bruja'])
    },
    comprehensive: {
        compatible: [
            ['Fine structure constant was introduced by %s, the currently accepted is %+20.9f, close to 1/%d.',
             'Arnold Sommerfeld', 7.297352569824e-3, 137]
        ]
    }
}


# @param [Object] value
# @return [String]
def convert_value_to_repr_format(value)
  case value
    when String
      "\"#{value}\""
    when Char
      "'#{value.to_s}'"
    when Symbol
      value.to_s
    else
      value.to_s
  end
end

# @param [Array] sprintf_format
def sprintf_format_to_args(sprintf_format)
  sprintf_format.map { |element| convert_value_to_repr_format(element) }.join(', ')
end

# @param [String] string
# @return [String]
def escape_single_quote(string)
  string.chars.map { |ch| ch == '\'' ? '\\\'' : ch }.join
end

# @param [Array] sprintf_format
# @param [String] expected
# @return [String]
def generate_sprintf_test_description(sprintf_format, expected)
  "'sprintf(#{escape_single_quote(sprintf_format_to_args(sprintf_format))}) => \"#{escape_single_quote(expected)}\"'"
end

# @param [Hash] incompatible_tests
# @return [Array]
def generate_incompatible_test(incompatible_tests)
  incompatible_tests.map do |sprintf_format, expected|
    case expected
      when String
        TEST_EQUAL_FORMAT % {
            description: generate_sprintf_test_description(sprintf_format, expected),
            sprintf_args: sprintf_format_to_args(sprintf_format),
            expected: convert_value_to_repr_format(expected)
        }
      when :sprintfException
        TEST_EXCEPTION_FORMAT % {
            description: generate_sprintf_test_description(sprintf_format, 'Error thrown'),
            sprintf_args: sprintf_format_to_args(sprintf_format)
        }
      else
        raise ArgumentError.new("Unexpected test expectation #{expected.class}, expected String or :sprintfException")
    end
  end
end

# @param [String] sprintf_format
# @return [String]
def generate_c_sprintf_code(sprintf_format)
  C_FILE_TEMPLATE % {:sprintf_args => sprintf_format_to_args(sprintf_format)}
end

# @param [String] c_code
def compile_c_code(c_code)
  compile_command = ([C_COMPILER] + C_COMPILER_FLAGS).join(' ')
  IO.popen(compile_command, 'w') do |stream|
    stream.write(c_code)
    stream.close_write
  end
end

def get_expected_from_c
  result = ''
  IO.popen(C_OUTPUT_FILE, 'r') do |stream|
    result =stream.read
  end
  result
end

# @param [Array] compatible_tests
# @return [Array]
def generate_compatible_test(compatible_tests)
  compatible_tests.map do |sprintf_format|
    compile_c_code(generate_c_sprintf_code(sprintf_format))
    expected = get_expected_from_c

    TEST_EQUAL_FORMAT % {
        :description => generate_sprintf_test_description(sprintf_format, expected),
        :sprintf_args => sprintf_format_to_args(sprintf_format),
        :expected => convert_value_to_repr_format(expected)
    }
  end
end

# @param [Array] conversion_specifier_test
def generate_conversion_specifier_test(conversion_specifier_test)
  incompatible = []
  compatible = []

  if conversion_specifier_test.include?(:incompatible)
    incompatible = generate_incompatible_test(conversion_specifier_test[:incompatible])
  end

  if conversion_specifier_test.include?(:compatible)
    compatible = generate_compatible_test(conversion_specifier_test[:compatible])
  end

  (incompatible + compatible).map { |line| line + "\n" }.join
end

def main
  File.open(OUTPUT_COFFEE_SCRIPT_FILE, 'w') do |output_file|
    output_file.write(COFFEESCRIPT_BANNER)

    TEST_SPRINTF_SETS.each_pair do |conversion_specifier, conversion_specifier_test|
      STDOUT.puts(conversion_specifier)
      STDOUT.flush
      test_set_function_head = TEST_FUNCTION_FORMAT % {:conversion_specifier => conversion_specifier}
      output_file.write("#{test_set_function_head}\n")
      output_file.write(generate_conversion_specifier_test(conversion_specifier_test))
    end
  end
end

main() if __FILE__ == $0